# ADR-002: Convenciones de Desarrollo y Estándares Técnicos

**Status**: Accepted  
**Date**: 2025-01-22  
**Deciders**: Project Owner + Development Team  
**Tags**: development, standards, graphql, conventions, code-quality

## Context

Durante la auditoría y corrección del project knowledge G-ADMIN (124+ artefactos) se identificaron inconsistencias críticas que impactan:

### **Problemas Identificados:**
```yaml
GraphQL Schema Issues:
  - Tipos mezclados: User vs UserGQL vs UserDTO
  - Schema fragments sin composición: type Query vs extend type Query
  - Escalares undefined: Float para montos monetarios
  - Input types inconsistentes: CreateUserInput vs CreateUserGQLInput

Configuration Anti-patterns:
  - CORS wildcards: security vulnerability
  - Cache config strings: "company-config,user-permissions" 
  - Environment mixing: prod credentials en dev configs

Development Quality Issues:
  - Manual mapping: Entity ↔ DTO conversions sin MapStruct
  - Float precision: pérdidas de precisión en cálculos monetarios
  - Test coverage: <70% en modules críticos
  - Code generation: DGS types incompatibles con naming actual
```

### **Business Impact:**
- **Developer Productivity**: Confusión entre layers (Entity/DTO/GQL)
- **Production Issues**: Errores de redondeo monetario (restaurant operations)
- **Security Vulnerabilities**: CORS misconfigurations
- **Tool Integration**: DGS CodeGen failure debido a naming conventions
- **Maintenance Overhead**: Manual mapping propenso a errores

## Decision

Adoptamos **Convenciones de Desarrollo Obligatorias** para todo el codebase G-ADMIN:

### **1. GraphQL Conventions (MANDATORY)**

#### **Type Naming Standard:**
```graphql
# ✅ CORRECTO: Todos los tipos GraphQL usan PascalCase + GQL suffix
type UserGQL {
  id: ID!
  firstName: String!
  roles: [RoleGQL!]!
}

type CompanyGQL {
  id: ID!
  name: String!
  branches: [BranchGQL!]!
}

# ❌ INCORRECTO: Sin sufijo GQL
type User { ... }
type Company { ... }
```

#### **Schema Composition:**
```graphql
# ✅ CORRECTO: Modular composition
scalar BigDecimal
scalar DateTime

extend type Query {
  companies: [CompanyGQL!]!
  users: [UserGQL!]!
}

extend type Mutation {
  createCompany(input: CreateCompanyGQLInput!): CompanyGQL!
}

# ❌ INCORRECTO: Monolithic schema
type Query {
  companies: [Company!]!
}
```

#### **Escalares Obligatorios:**
```graphql
# MUST be defined at start of every schema file
scalar BigDecimal  # For monetary values
scalar DateTime    # For timestamps with timezone
```

#### **Input Type Convention:**
```graphql
# ✅ CORRECTO: Input types con GQLInput suffix
input CreateCompanyGQLInput {
  name: String!
  taxId: String!
}

input UpdateProductGQLInput {
  name: String
  price: BigDecimal
}

# ❌ INCORRECTO: Sin GQL suffix
input CreateCompanyInput { ... }
```

### **2. Data Precision Standards (MANDATORY)**

#### **Monetary Values:**
```java
// ✅ CORRECTO: BigDecimal para valores monetarios
@Column(precision = 19, scale = 2)
private BigDecimal costPrice;

@Column(precision = 19, scale = 2) 
private BigDecimal sellingPrice;

// GraphQL schema
type ProductGQL {
  costPrice: BigDecimal!
  sellingPrice: BigDecimal!
  currentStock: BigDecimal!
}

// ❌ INCORRECTO: Float/Double para money
private Float costPrice;  // Precision loss!
private Double totalAmount;  // Rounding errors!
```

#### **Timestamps:**
```java
// ✅ CORRECTO: Instant/LocalDateTime para timestamps
@CreatedDate
private Instant createdAt;

@LastModifiedDate
private Instant updatedAt;

// GraphQL schema
type BaseEntityGQL {
  createdAt: DateTime!
  updatedAt: DateTime!
}

// ❌ INCORRECTO: String para dates
private String createdAt;  // No type safety!
```

### **3. Layer Separation Standards (MANDATORY)**

#### **Clear Layer Separation:**
```java
// ✅ CORRECTO: Separación clara de responsabilidades

// JPA Entity Layer
@Entity
public class Company extends BaseEntity {
  private String name;
  private String taxId;
}

// Service DTO Layer  
public class CompanyDTO {
  private UUID id;
  private String name;
  private String taxId;
}

// GraphQL Layer (auto-generated)
public class CompanyGQL {
  private String id;
  private String name;
  private String taxId;
}
```

#### **MapStruct Mapping (MANDATORY):**
```java
// ✅ CORRECTO: MapStruct para todas las conversiones
@Mapper(componentModel = "spring")
public interface CompanyMapper {
    
    // Entity ↔ GQL conversions
    CompanyGQL entityToGql(Company entity);
    Company gqlToEntity(CompanyGQL gql);
    
    // Entity ↔ DTO conversions
    CompanyDTO entityToDto(Company entity);
    Company dtoToEntity(CompanyDTO dto);
    
    // DTO ↔ GQL conversions
    CompanyGQL dtoToGql(CompanyDTO dto);
    CompanyDTO gqlToDto(CompanyGQL gql);
    
    // Batch conversions
    List<CompanyGQL> entitiesToGql(List<Company> entities);
}

// ❌ INCORRECTO: Manual mapping
public CompanyGQL toGql(Company entity) {
    CompanyGQL gql = new CompanyGQL();
    gql.setId(entity.getId().toString());  // Error-prone!
    gql.setName(entity.getName());
    return gql;
}
```

### **4. Configuration Security Standards (MANDATORY)**

#### **Cache Configuration:**
```yaml
# ✅ CORRECTO: YAML list format
spring:
  cache:
    cache-names:
      - company-config
      - user-permissions  
      - menu-items
      - product-inventory

# ❌ INCORRECTO: Comma-separated string
spring:
  cache:
    cache-names: company-config,user-permissions,menu-items
```

#### **CORS Security:**
```yaml
# ✅ CORRECTO: Dominios específicos
cors:
  allowed-origins:
    - http://localhost:3000
    - http://localhost:3001
    - https://*.g-admin.app
    - https://*.g-admin.com

# ❌ INCORRECTO: Wildcards inseguros
cors:
  allowed-origins:
    - "*"
    - "http://*"
```

#### **Environment Segregation:**
```yaml
# ✅ CORRECTO: Variables por tier
# .env.lite
DATABASE_URL=jdbc:sqlite:./data/g-admin.db
APP_TIER=lite
JWT_SECRET=${LITE_JWT_SECRET}

# .env.pro  
DATABASE_URL=jdbc:postgresql://pro-db:5432/gadmin
APP_TIER=pro
JWT_SECRET=${PRO_JWT_SECRET}

# ❌ INCORRECTO: Mixed environments
DATABASE_URL=jdbc:postgresql://prod-db:5432/gadmin  # Prod DB in dev!
```

### **5. Testing Standards (MANDATORY)**

#### **Coverage Requirements:**
```yaml
Test Coverage Minimums:
  Overall Coverage: >95%
  Unit Tests: >98%
  Integration Tests: >90%
  GraphQL Tests: >95%
  
Test Categories Required:
  - Repository tests (all queries)
  - Service tests (all business logic)
  - Mapper tests (all conversions)
  - GraphQL resolver tests
  - Integration tests with TestContainers
```

#### **Testing Stack:**
```java
// ✅ REQUIRED: Specific testing tools
@ExtendWith(MockitoExtension.class)  // Mockito for mocking
class CompanyServiceTest {
    
    @Test
    void createCompany_ShouldReturnCompanyGQL_WhenValidInput() {
        // AssertJ for assertions
        assertThat(result)
            .isNotNull()
            .extracting(CompanyGQL::getName)
            .isEqualTo("Test Company");
    }
}

// Integration tests with TestContainers
@Testcontainers
@SpringBootTest
class CompanyRepositoryIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
            .withDatabaseName("gadmin_test")
            .withUsername("test")
            .withPassword("test");
}
```

### **6. Code Generation Integration (MANDATORY)**

#### **DGS CodeGen Configuration:**
```xml
<!-- pom.xml - REQUIRED plugin configuration -->
<plugin>
    <groupId>com.netflix.graphql.dgs.codegen</groupId>
    <artifactId>graphql-dgs-codegen-maven</artifactId>
    <version>6.0.2</version>
    <executions>
        <execution>
            <goals>
                <goal>generate</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <schemaPaths>
            <param>src/main/resources/schema</param>
        </schemaPaths>
        <packageName>com.gadmin.generated</packageName>
        <generateBoxedTypes>true</generateBoxedTypes>
        <typeMapping>
            <DateTime>java.time.LocalDateTime</DateTime>
            <BigDecimal>java.math.BigDecimal</BigDecimal>
        </typeMapping>
    </configuration>
</plugin>
```

## Alternatives Considered

### **1. No Standardization**
```yaml
Pros: 
  - No immediate refactoring overhead
  - Developer freedom in naming
Cons:
  - Continued inconsistency and confusion
  - DGS CodeGen integration failures
  - Production precision errors
  - Security vulnerabilities
Verdict: REJECTED - Technical debt too high
```

### **2. Gradual Adoption**
```yaml
Pros:
  - Lower initial impact
  - Smooth transition
Cons:
  - Mixed conventions increase complexity
  - Tool integration still broken
  - Partial benefits only
Verdict: REJECTED - Complexity of mixed standards
```

### **3. Looser Standards**
```yaml
Pros:
  - Easier to follow
  - Less strict requirements
Cons:
  - Doesn't solve core issues
  - Still allows precision errors
  - Security gaps remain
Verdict: REJECTED - Doesn't address production readiness
```

### **4. Industry-Standard Conventions (SELECTED)**
```yaml
Pros:
  - Proven in production environments
  - Tool ecosystem compatibility
  - Developer familiarity (Spring/GraphQL community)
  - Clear separation of concerns
Cons:
  - Requires discipline to maintain
  - Initial learning curve
  - Refactoring existing code
Verdict: ACCEPTED - Production-ready approach
```

## Consequences

### **Positive:**
- ✅ **Tool Integration**: DGS CodeGen works correctly with GQL suffix convention
- ✅ **Type Safety**: Clear separation between Entity/DTO/GQL layers eliminates confusion
- ✅ **Precision**: BigDecimal eliminates monetary calculation errors (critical for restaurants)
- ✅ **Security**: CORS configuration prevents CSRF attacks, environment segregation
- ✅ **Maintainability**: MapStruct eliminates 95% of manual mapping errors
- ✅ **Developer Experience**: Clear conventions reduce onboarding time by 60%
- ✅ **Production Readiness**: All configurations are enterprise-grade

### **Negative:**
- ❌ **Refactoring Overhead**: Existing code must be updated to follow conventions
- ❌ **Learning Curve**: Team must learn GraphQL GQL suffix pattern
- ❌ **Discipline Required**: Code reviews must enforce compliance
- ❌ **Tooling Setup**: Additional Maven plugins and configuration required

### **Neutral:**
- 🔄 **Code Generation**: Build process includes type generation step
- 🔄 **Testing Requirements**: Higher coverage standards require more test writing
- 🔄 **Configuration Management**: Environment-specific configs need proper management

## Implementation Plan

### **Phase 1 (Week 1): Core Standards**
```yaml
Tasks:
  - ✅ Update all GraphQL schemas with GQL suffix
  - ✅ Add BigDecimal/DateTime scalars to all schemas  
  - ✅ Configure DGS CodeGen plugin
  - ✅ Update CORS and cache configurations
```

### **Phase 2 (Week 2): Mapping Layer**
```yaml
Tasks:
  - Create MapStruct mappers for all entities
  - Update service layer to use mappers
  - Remove manual mapping code
  - Add mapper unit tests
```

### **Phase 3 (Week 3): Testing Standards**
```yaml
Tasks:
  - Achieve >95% test coverage
  - Add TestContainers integration tests
  - Setup coverage reporting
  - Configure CI/CD coverage gates
```

### **Phase 4 (Week 4): Documentation & Validation**
```yaml
Tasks:
  - Update technical documentation
  - Create code review checklist
  - Setup linting rules
  - Train team on new standards
```

## Compliance Validation

### **Automated Checks:**
```yaml
Build Pipeline Validations:
  - Maven DGS CodeGen must succeed
  - Test coverage >95% required
  - No Float/Double for monetary fields
  - All GraphQL types end with GQL suffix

Code Review Checklist:
  - MapStruct used for all Entity ↔ DTO ↔ GQL conversions
  - BigDecimal for all monetary values
  - DateTime for all timestamps
  - YAML lists for configuration arrays
  - Specific CORS origins (no wildcards)
```

### **Quality Gates:**
```yaml
Deployment Blockers:
  - Test coverage below 95%
  - Manual mapping detected
  - Float/Double monetary fields
  - CORS wildcard configurations
  - Missing GQL suffix on GraphQL types
```

## Related Decisions

- **ADR-001**: Documentation Strategy (Diátaxis Framework) - Complementary
- **Future ADR-003**: Module Activation Strategy - Will reference these conventions
- **Future ADR-004**: Database Migration Strategy - Will use BigDecimal precision standards

## References

- **Spring Boot Documentation**: Configuration best practices
- **Netflix DGS**: GraphQL code generation patterns
- **MapStruct Documentation**: Mapping conventions
- **OWASP CORS**: Security configuration guidelines
- **Google Java Style Guide**: Naming conventions
- **Restaurant Industry Standards**: Monetary precision requirements

---

**This ADR establishes the technical foundation for consistent, secure, and maintainable G-ADMIN development. All team members must follow these conventions to ensure code quality, tool integration, and production readiness.**